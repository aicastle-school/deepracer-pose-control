<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <div>Teachable Machine Pose Model</div>
<!-- <img src="https://192.168.1.2/route?topic=/camera_pkg/display_mjpeg&width=480&height=360" crossorigin="use-credentials"> -->
<button type='button' onclick='init()'>Start</button>
<div><canvas id='canvas'></canvas></div>
<div id='label-container'></div>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@teachablemachine/pose@0.8.3/dist/teachablemachine-pose.min.js"></script>
<script type="text/javascript">
    // More API functions here:
    // https://github.com/googlecreativelab/teachablemachine-community/tree/master/libraries/pose

    // the link to your model provided by Teachable Machine export panel
    const URL = './';
    let model, webcam, ctx, labelContainer, maxPredictions;

    async function init() {
        const modelURL = URL + '/model.json';
        const metadataURL = URL + '/metadata.json';
        
        // load the model and metadata
        // Refer to tmPose.loadFromFiles() in the API to support files from a file picker
        model = await tmPose.load(modelURL, metadataURL);
        maxPredictions = model.getTotalClasses();

        // Convenience function to setup a webcam
        const flip = true; // whether to flip the webcam
        webcam = new tmPose.Webcam(200, 200, flip); // width, height, flip
        await webcam.setup(); // request access to the webcam
        webcam.play();
        window.requestAnimationFrame(loop);

        // append/get elements to the DOM
        const canvas = document.getElementById('canvas');
        canvas.width = 200; canvas.height = 200;
        ctx = canvas.getContext('2d');
        labelContainer = document.getElementById('label-container');
        for (let i = 0; i < maxPredictions; i++) { // and class labels
            labelContainer.appendChild(document.createElement('div'));
        }
    }

    async function loop(timestamp) {
        webcam.update(); // update the webcam frame
        await predict();
        window.requestAnimationFrame(loop);
    }

    let lastLogTime = 0; // ÎßàÏßÄÎßâÏúºÎ°ú Î°úÍ∑∏Î•º Ï∞çÏùÄ ÏãúÍ∞Ñ Í∏∞Î°ù

    async function predict() {
        // Prediction #1: run input through posenet
        // estimatePose can take in an image, video or canvas html element
        const { pose, posenetOutput } = await model.estimatePose(webcam.canvas);
        // Prediction 2: run input through teachable machine classification model
        const prediction = await model.predict(posenetOutput);

        // ÎèôÏûëÎ≥Ñ ÌôïÎ•†ÏùÑ Í∞ùÏ≤¥Î°ú Ï†ÄÏû•
        const predictionMap = {};

        // for (let i = 0; i < maxPredictions; i++) {
        //     const classPrediction =
        //         prediction[i].className + ': ' + prediction[i].probability.toFixed(2);
        //     labelContainer.childNodes[i].innerHTML = classPrediction;

        //     // prediction[i].className (ÏßÅÏßÑ, Ï¢åÌöåÏ†Ñ, Ïö∞ÌöåÏ†Ñ) 
        //     // console.log(prediction[i].probability.toFixed(2))
        // }


        const now = Date.now();


        const poseToDriveCommand = {
            "Îπ†Î•∏ ÏßÅÏßÑ":    { angle: 0.0, speed: 1.0 },
            "ÎäêÎ¶∞ ÏßÅÏßÑ":    { angle: 0.0, speed: 0.5 },
            "Îπ†Î•∏ Ï¢åÌöåÏ†Ñ":  { angle: -1.0, speed: 1.0 },
            "ÎäêÎ¶∞ Ï¢åÌöåÏ†Ñ":  { angle: -1.0, speed: 0.5 },
            "Îπ†Î•∏ Ïö∞ÌöåÏ†Ñ":  { angle: 1.0, speed: 1.0 },
            "ÎäêÎ¶∞ Ïö∞ÌöåÏ†Ñ":  { angle: 1.0, speed: 0.5 }
        };

        if(now - lastLogTime > 10000) {

        // Í∞ÄÏû• ÌôïÎ•† ÎÜíÏùÄ ÌÅ¥ÎûòÏä§ ÏÑ†ÌÉù
        const top = prediction.reduce((prev, current) => (
            prev.probability > current.probability ? prev : current
        ));

           if (top.probability >= 0.8 && poseToDriveCommand[top.className]) {
            const { angle, speed } = poseToDriveCommand[top.className];

            const data = {
                angle: -Math.max(-1, Math.min(1, angle)),
                throttle: -Math.max(-1, Math.min(1, speed)),
                max_speed: speed
            };

            console.log("Î≥¥ÎÇ¥Îäî Îç∞Ïù¥ÌÑ∞:", JSON.stringify(data));

            fetch('https://192.168.1.2/api/manual_drive', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify(data)
            })
            .then(res => res.text())  // ÏùëÎãµÏù¥ JSON ÏïÑÎãê ÏàòÎèÑ ÏûàÏñ¥
            .then(text => {
            console.log("‚úÖ ÏÑúÎ≤Ñ ÏùëÎãµ Î≥∏Î¨∏:", text);
            })
            .catch(err => console.error("‚ùå Ïò§Î•ò:", err));
        }    

        for (let i = 0; i < maxPredictions; i++) {
                const label = prediction[i].className;
                const prob = prediction[i].probability;
                predictionMap[label] = prob;

                // UI ÌëúÏãú
                const classPrediction = label + ': ' + prob.toFixed(2);
                labelContainer.childNodes[i].innerHTML = classPrediction;

                // console.log("üîç ÏòàÏ∏° Í≤∞Í≥º:", predictionMap);

                // Ïòà: ÌôïÎ•†Ïù¥ 0.8 Ïù¥ÏÉÅÏùº ÎïåÎßå ÎèôÏûë Ï≤òÎ¶¨
                if (prob >= 0.5) {
                    switch (label) {
                        case "Îπ†Î•∏ ÏßÅÏßÑ":
                            console.log("üöÄ Îπ†Î•∏ ÏßÅÏßÑ Í∞êÏßÄ:", prob.toFixed(2));
                            // ÎèôÏûë Ï≤òÎ¶¨ ÏΩîÎìú
                            break;
                        case "ÎäêÎ¶∞ ÏßÅÏßÑ":
                            console.log("üö∂ ÎäêÎ¶∞ ÏßÅÏßÑ Í∞êÏßÄ:", prob.toFixed(2));
                            break;

                        case "Îπ†Î•∏ Ï¢åÌöåÏ†Ñ":
                            console.log("‚Ü™Ô∏è Îπ†Î•∏ Ï¢åÌöåÏ†Ñ Í∞êÏßÄ:", prob.toFixed(2));
                            break;

                        case "ÎäêÎ¶∞ Ï¢åÌöåÏ†Ñ":
                            console.log("‚Ü©Ô∏è ÎäêÎ¶∞ Ï¢åÌöåÏ†Ñ Í∞êÏßÄ:", prob.toFixed(2));
                            break;

                        case "Îπ†Î•∏ Ïö∞ÌöåÏ†Ñ":
                            console.log("‚û°Ô∏è Îπ†Î•∏ Ïö∞ÌöåÏ†Ñ Í∞êÏßÄ:", prob.toFixed(2));
                            break;

                        case "ÎäêÎ¶∞ Ïö∞ÌöåÏ†Ñ":
                            console.log("‚¨ÖÔ∏è ÎäêÎ¶∞ Ïö∞ÌöåÏ†Ñ Í∞êÏßÄ:", prob.toFixed(2));
                            break;

                        default:
                            console.log("ü§∑ Ïïå Ïàò ÏóÜÎäî ÎèôÏûë:", label, prob.toFixed(2));
                    }
                }
            }

               lastLogTime = now; // ÎßàÏßÄÎßâ Î°úÍ∑∏ ÏãúÍ∞Ñ Í∞±Ïã†
        }

        

        // finally draw the poses
        drawPose(pose);
    }

    function drawPose(pose) {
        ctx.drawImage(webcam.canvas, 0, 0);
        // draw the keypoints and skeleton
        if (pose) {
            const minPartConfidence = 0.5;
            tmPose.drawKeypoints(pose.keypoints, minPartConfidence, ctx);
            tmPose.drawSkeleton(pose.keypoints, minPartConfidence, ctx);
        }
    }

    // const url = 'https://192.168.1.2/route?topic=/camera_pkg/display_mjpeg&width=480&height=360' 
    //     fetch(url, {
    //         method: 'GET',
    //         credentials: 'include',
    //             // headers: {
    //             //     // 'Authorization': 'Bearer YOUR_TOKEN',
    //             //     // ÎòêÎäî ÌÖåÏä§Ìä∏Ïö© Ïø†ÌÇ§Î•º Í∞ïÏ†úÎ°ú Ï∂îÍ∞ÄÌï¥Î≥º ÏàòÎèÑ ÏûàÏùå (ÏùºÏãúÏ†Å ÎîîÎ≤ÑÍπÖ Ïö©ÎèÑ)
    //             //     'Cookie': 'session_id=abc123'
    //             // }
    //     }).then(response => {

    //         console.log("Ïä§ÌÖåÏù¥ÌÑ∞Ïä§ ÌôïÏù∏")
    //         console.log(response.status)
    //         if (response.ok) {
    //             console.log("ÏÑ±Í≥µ")
    //             console.log('Stream started successfully');
    //         } else {
    //             console.error('Error starting stream:', response.statusText);
    //             console.log("ÏóêÎü¨111")
    //         }
    //     }).catch(error => {
    //         console.log("ÏóêÎü¨222")
    //         console.error('Error:', error);
    //     });

</script>
</body>
</html>